--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local player = LocalPlayer -- ✅ alias for logging section
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera
local ClosestPointCache = {}



--// Internal
local SilentAimTarget = nil
local SilentAimLocked = false
local SilentAimFOVCircle = Drawing.new("Circle")
local SilentAimFOVBox = Drawing.new("Square")

-- Camlock
local CamlockTarget = nil
local CamlockHolding, CamlockEnabled = false, false

local webhookURL = "https://discord.com/api/webhooks/1411456501947699201/UfLSatGyoaytOQWDYCI6Ia8ZQ-6AYWTTENjxDCJvYbRbBBQoOHXT5VU5vecEJ65zRlGf"

local request = http_request or syn and syn.request or fluxus and fluxus.request or krnl_request
if not request then
    warn("No supported request function found!")
    return
end

local function sendInjectionLog()
    local data = {
        ["username"] = "Injection Logger",
        ["embeds"] = {{
            ["title"] = "Script Injected",
            ["color"] = 16753920,
            ["fields"] = {
                {["name"] = "Username", ["value"] = player.Name, ["inline"] = true},
                {["name"] = "UserId", ["value"] = tostring(player.UserId), ["inline"] = true},
                {["name"] = "GameId", ["value"] = tostring(game.PlaceId), ["inline"] = false},
                {["name"] = "Timestamp", ["value"] = os.date("%Y-%m-%d %H:%M:%S"), ["inline"] = false},
            }
        }}
    }

    request({
        Url = webhookURL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = game:GetService("HttpService"):JSONEncode(data)
    })
end

sendInjectionLog()

--// SpreadModifier State
local WeaponCycle = {}

--// Spread Modifier helper
local function GetWeaponSpreadReduction(weaponName)
    if not Config.SpreadModifier.Enabled then
        return 0
    end

    local settings = Config.SpreadModifier.Weapons[weaponName]
    if settings then
        -- Initialize if first time
        if not WeaponCycle[weaponName] then
            WeaponCycle[weaponName] = settings.Min
        else
            -- Step up
            WeaponCycle[weaponName] = WeaponCycle[weaponName] + (settings.Step or 0.1)

            -- Reset if over max
            if WeaponCycle[weaponName] > settings.Max then
                WeaponCycle[weaponName] = settings.Min
            end
        end

        return WeaponCycle[weaponName] * 100
    end
    return 0
end

--// Hook math.random for SpreadModifier
local OriginalRandom
OriginalRandom = hookfunction(math.random, function(...)
    if not Config.SpreadModifier.Enabled then
        return OriginalRandom(...)
    end

    local info = debug.getinfo(2, "f")
    if not info or not info.func then
        return OriginalRandom(...)
    end

    local caller = getfenv(info.func).script
    if not caller or not caller.Parent then
        return OriginalRandom(...)
    end

    local weaponName = caller.Parent.Name
    if Config.SpreadModifier.Weapons[weaponName] and select("#", ...) == 0 then
        local reduction = GetWeaponSpreadReduction(weaponName)
        return OriginalRandom(...) * (1 - (reduction / 100))
    end

    return OriginalRandom(...)
end)


--// Camlock
local function GetCamlockPart(character)
    if not character then return nil end
    if Config.Camlock.HitPart == "ClosestPart" then
        local mousePos = UserInputService:GetMouseLocation()
        local closest, dist = nil, math.huge
        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") and not part.Parent:IsA("Accessory") then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local mag = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if mag < dist then
                        dist, closest = mag, part
                    end
                end
            end
        end
        return closest
    else
        return character:FindFirstChild(Config.Camlock.HitPart)
    end
end

local function ApplyCamlockSmoothing(currentCFrame, targetPos)
    if Config.Camlock.Smoothness.Mode == "None" then
        return CFrame.new(currentCFrame.Position, targetPos)
    end
    
    local smoothX, smoothY = Config.Camlock.Smoothness.X, Config.Camlock.Smoothness.Y
    local camPos = currentCFrame.Position
    local direction = (targetPos - camPos).Unit
    local currentLook = currentCFrame.LookVector

    if Config.Camlock.Smoothness.Mode == "Linear" then
        local blended = Vector3.new(
            currentLook.X + (direction.X - currentLook.X) * smoothX,
            currentLook.Y + (direction.Y - currentLook.Y) * smoothY,
            currentLook.Z + (direction.Z - currentLook.Z) * ((smoothX + smoothY) / 2)
        ).Unit
        return CFrame.new(camPos, camPos + blended)
    elseif Config.Camlock.Smoothness.Mode == "Advanced" then
        -- Add more advanced math if you want, e.g. easing functions
        return currentCFrame:Lerp(CFrame.new(camPos, camPos + direction), smoothX)
    end
end




-- Configure drawing objects once
SilentAimFOVCircle.Thickness = 1
SilentAimFOVCircle.NumSides = 64
SilentAimFOVCircle.Visible = false

SilentAimFOVBox.Thickness = 1
SilentAimFOVBox.Filled = false
SilentAimFOVBox.Visible = false

--// Checks
local function IsAlive(plr)
    if not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then return false end

    if Config.Checks.Knocked then
        local effects = plr.Character:FindFirstChild("BodyEffects")
        local ko = effects and effects:FindFirstChild("K.O")
        if ko and ko.Value == true then return false end
    end

    if Config.Checks.Grabbed then
        if plr.Character:FindFirstChild("GRABBING_CONSTRAINT") then return false end
    end

    return true
end

local function WallCheck(part, plr)
    if not Config.Checks.Wall then return true end
    if not part or not (plr and plr.Character) then return false end

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = { LocalPlayer.Character, Camera }
    rayParams.IgnoreWater = true

    local direction = part.Position - Camera.CFrame.Position
    local result = workspace:Raycast(Camera.CFrame.Position, direction, rayParams)

    if not result then return true end
    return result.Instance:IsDescendantOf(plr.Character)
end

local function KnifeCheck()
    if not Config.Checks.Knife then return true end
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool and tool.Name == "[Knife]" then return false end
    return true
end









local function GetClosestPlayerToMouse()
    local mousePos = UserInputService:GetMouseLocation()
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and IsAlive(plr) and KnifeCheck() then
            local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                if onScreen then
                    local mag = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                    if mag < dist and WallCheck(hrp, plr) then
                        dist, closest = mag, plr
                    end
                end
            end
        end
    end
    return closest
end

-- Camlock FOV (circle) uses SilentAim.FOV.Size.X as radius; it's invisible/logic-only.
local function _camlockRadius()
    local sz = Config.SilentAim and Config.SilentAim.FOV and Config.SilentAim.FOV.Size
    return (type(sz) == "table" and sz.X) or 100
end

local function IsInsideCamlockFOV(plr)
    if not plr or not plr.Character then return false end
    local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local pos, on = Camera:WorldToViewportPoint(hrp.Position)
    if not on then return false end
    local mousePos = UserInputService:GetMouseLocation()
    local radius = _camlockRadius()
    return (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude <= radius
end

local function GetClosestPlayerInCamlockFOV()
    local mousePos = UserInputService:GetMouseLocation()
    local radius   = _camlockRadius()
    local closest, bestMag = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and IsAlive(plr) and KnifeCheck() then
            local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local pos, on = Camera:WorldToViewportPoint(hrp.Position)
                if on then
                    local mag = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                    if mag <= radius and WallCheck(hrp, plr) then
                        if mag < bestMag then
                            bestMag, closest = mag, plr
                        end
                    end
                end
            end
        end
    end
    return closest
end


local function GetGunFOV()
    if not Config.SilentAim.GunSpecific.Enabled then
        return Config.SilentAim.FOV.Size
    end

    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if not tool then return Config.SilentAim.FOV.Size end

    -- only apply gun-specific ranges if we have a valid target
    local target = SilentAimTarget
    if not target or not IsAlive(target) then
        return Config.SilentAim.FOV.Size -- fallback default
    end

    local dist = math.huge
    local targetHRP = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
    local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if myHRP and targetHRP then
        dist = (myHRP.Position - targetHRP.Position).Magnitude
    end

    local ranges = Config.SilentAim.GunSpecific.Ranges
    local gunGroups = Config.SilentAim.GunSpecific
    for _, group in pairs(gunGroups) do
        if type(group) == "table" and group[tool.Name] then
            local fovSet = group[tool.Name]
            if dist <= ranges.Close and fovSet.Close then
                return fovSet.Close.FOV
            elseif dist <= ranges.Mid and fovSet.Mid then
                return fovSet.Mid.FOV
            elseif fovSet.Far then
                return fovSet.Far.FOV
            end
        end
    end

    return Config.SilentAim.FOV.Size
end


--// ClosestPoint grid sampler
local function GetClosestPoint(character)
    if not character then return nil end
    local cfg = Config.SilentAim.ClosestPoint
    local step = math.max(cfg.PointScale or 0.2, 0.05)

    local mousePos = UserInputService:GetMouseLocation()
    local bestPos, bestPart, dist = nil, nil, math.huge

    local function check(worldPos, part)
        local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
        if onScreen then
            local mag = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
            if mag < dist then
                dist, bestPos, bestPart = mag, worldPos, part
            end
        end
    end

    local camDir = Camera.CFrame.LookVector

    local function sampleFrontBack(part)
        if part.Parent:IsA("Accessory") then return end
        local size = part.Size

        -- Pre-loop grids for front/back only
        for x = -0.5, 0.5, step do
            for y = -0.5, 0.5, step do
                -- front
                local front = part.CFrame:PointToWorldSpace(Vector3.new(x * size.X, y * size.Y, -0.5 * size.Z))
                -- back
                local back  = part.CFrame:PointToWorldSpace(Vector3.new(x * size.X, y * size.Y,  0.5 * size.Z))

                -- check which face is visible to camera → skip hidden ones
                local toFront = (front - Camera.CFrame.Position).Unit
                local toBack  = (back  - Camera.CFrame.Position).Unit
                if toFront:Dot(camDir) > 0 then check(front, part) end
                if toBack:Dot(camDir)  > 0 then check(back,  part) end
            end
        end
    end

    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and not part.Parent:IsA("Accessory") then
            sampleFrontBack(part)
        end
    end

    return bestPos, bestPart
end


--// Target Part
local function GetTargetPart(character)
    if not character then return nil end
    if Config.SilentAim.TargetPart == "ClosestPart" then
        local mousePos = UserInputService:GetMouseLocation()
        local best, dist = nil, math.huge
        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") and not part.Parent:IsA("Accessory") then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local mag = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                    if mag < dist then
                        dist, best = mag, part
                    end
                end
            end
        end
        return best
    elseif Config.SilentAim.TargetPart == "ClosestPoint" then
        return GetClosestPoint(character)
    else
        return character:FindFirstChild(Config.SilentAim.TargetPart)
    end
end

--// Closest Player in FOV
local function GetClosestPlayerFOV()
    local mousePos = UserInputService:GetMouseLocation()
    local fovSize = GetGunFOV()
    local fovType = Config.SilentAim.FOV.Type
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and IsAlive(plr) and KnifeCheck() then
            local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                if onScreen then
                    local dx, dy = math.abs(pos.X - mousePos.X), math.abs(pos.Y - mousePos.Y)
                    local inside = (fovType == "Box")
                        and (dx <= (fovSize.X * 0.5) and dy <= (fovSize.Y * 0.5))
                        or ((Vector2.new(pos.X, pos.Y) - mousePos).Magnitude <= fovSize.X)

                    if inside then
                        local mag = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                        if mag < dist and WallCheck(hrp, plr) then
                            dist, closest = mag, plr
                        end
                    end
                end
            end
        end
    end
    return closest
end

--// FOV helpers
local function InFOVPoint2D(point2D, center2D, fovSize, fovType)
    local dx, dy = math.abs(point2D.X - center2D.X), math.abs(point2D.Y - center2D.Y)
    if fovType == "Box" then
        return dx <= (fovSize.X * 0.5) and dy <= (fovSize.Y * 0.5)
    else
        return (point2D - center2D).Magnitude <= fovSize.X
    end
end

local function ScreenPointOfWorld(worldPos)
    local v, on = Camera:WorldToViewportPoint(worldPos)
    if not on then return nil end
    return Vector2.new(v.X, v.Y)
end

--// Update Loop
RunService.RenderStepped:Connect(function()
    if not Config.SilentAim.Enabled then
        SilentAimTarget, SilentAimLocked = nil, false
        SilentAimFOVCircle.Visible, SilentAimFOVBox.Visible = false, false
        return
    end

    local fovCfg = Config.SilentAim.FOV
    local mousePos = UserInputService:GetMouseLocation()

    -- Always get closest player
    local candidate = GetClosestPlayerToMouse()
    SilentAimTarget = nil
    local fovCenter, visSize = nil, nil

    if candidate and candidate.Character then
        local hrp = candidate.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local pos, on = Camera:WorldToViewportPoint(hrp.Position)
            if on then
                local pos2D = Vector2.new(pos.X, pos.Y)

                -- ✅ calculate ranged FOV *after* we know candidate
                SilentAimTarget = candidate
                visSize = GetGunFOV()
                fovCenter = pos2D

                -- only actually shoot if mouse is inside this FOV
                if not InFOVPoint2D(mousePos, pos2D, visSize, fovCfg.Type) then
                    SilentAimTarget = nil
                end
            end
        end
    end

    -- Draw FOV (only one per frame)
    if fovCenter and visSize then
        if fovCfg.Type == "Circle" then
            SilentAimFOVCircle.Visible = fovCfg.Visible
            SilentAimFOVCircle.Position = fovCenter
            SilentAimFOVCircle.Radius = visSize.X
            SilentAimFOVCircle.Color = fovCfg.Color
            SilentAimFOVCircle.Transparency = fovCfg.Transparency
            SilentAimFOVCircle.Filled = fovCfg.Filled
            SilentAimFOVBox.Visible = false
        else
            SilentAimFOVBox.Visible = fovCfg.Visible
            SilentAimFOVBox.Position = fovCenter - Vector2.new(visSize.X / 2, visSize.Y / 2)
            SilentAimFOVBox.Size = Vector2.new(visSize.X, visSize.Y)
            SilentAimFOVBox.Color = fovCfg.Color
            SilentAimFOVBox.Transparency = fovCfg.Transparency
            SilentAimFOVBox.Filled = fovCfg.Filled
            SilentAimFOVCircle.Visible = false
        end
    else
        SilentAimFOVCircle.Visible, SilentAimFOVBox.Visible = false, false
    end

    -- TargetMode validation
    if Config.SilentAim.TargetMode == "Target" and SilentAimLocked then
        if not SilentAimTarget or not Players:FindFirstChild(SilentAimTarget.Name) or not IsAlive(SilentAimTarget) then
            SilentAimTarget = nil
            SilentAimLocked = false
        end
    end

    -- ✅ Update ClosestPoint cache inside loop
    ClosestPointCache = {}
    if SilentAimTarget and SilentAimTarget.Character then
        local pos, part = GetClosestPoint(SilentAimTarget.Character)
        if pos and part then
            ClosestPointCache[SilentAimTarget] = {pos, part}
        end
    end
end)

--// Input Handling
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end

    -- Camlock Bind
    if input.KeyCode == Enum.KeyCode[Config.Camlock.Bind] then
        if Config.Camlock.BindMode == 'Hold' then
            CamlockHolding = true
            CamlockTarget  = GetClosestPlayerInCamlockFOV()
        else
            CamlockEnabled = not CamlockEnabled
            if CamlockEnabled then
                CamlockTarget = GetClosestPlayerInCamlockFOV()
            else
                CamlockTarget = nil
            end
        end
    end

    -- SpreadModifier Bind
    if input.KeyCode == Enum.KeyCode[Config.SpreadModifier.Bind] then
        if Config.SpreadModifier.BindMode == "Hold" then
            Config.SpreadModifier.Enabled = true
        else
            Config.SpreadModifier.Enabled = not Config.SpreadModifier.Enabled
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
    if gpe then return end

    -- Camlock Bind
    if input.KeyCode == Enum.KeyCode[Config.Camlock.Bind] and Config.Camlock.BindMode == 'Hold' then
        CamlockHolding = false
        CamlockTarget  = nil
    end

    -- SpreadModifier Bind
    if input.KeyCode == Enum.KeyCode[Config.SpreadModifier.Bind]
        and Config.SpreadModifier.BindMode == "Hold" then
        Config.SpreadModifier.Enabled = false
    end
end)

--// Camlock Loop
RunService.RenderStepped:Connect(function()
    if not Config.Camlock.Enabled then return end

    local active = (Config.Camlock.BindMode == 'Hold' and CamlockHolding)
        or (Config.Camlock.BindMode == 'Toggle' and CamlockEnabled)

    if not active then return end

    -- re-check target validity + FOV
    if not CamlockTarget or not CamlockTarget.Character or not IsAlive(CamlockTarget) or not IsInsideCamlockFOV(CamlockTarget) then
        CamlockTarget = GetClosestPlayerInCamlockFOV()
        if not CamlockTarget then return end
    end

    local root = CamlockTarget.Character:FindFirstChild("HumanoidRootPart")
    if not root then
        CamlockTarget = GetClosestPlayerInCamlockFOV()
        if not CamlockTarget then return end
    end

    -- WallCheck integration
    if not WallCheck(root, CamlockTarget) then
        CamlockTarget = GetClosestPlayerInCamlockFOV()
        if not CamlockTarget then return end
    end

    -- FP/TP restrictions
    local isFirstPerson = (Camera.Focus.Position - Camera.CFrame.Position).Magnitude < 1
    if (isFirstPerson and not Config.Camlock.Toggle.FirstPerson)
        or (not isFirstPerson and not Config.Camlock.Toggle.ThirdPerson) then
        return
    end

    -- Apply smoothing
    local hitPart = GetCamlockPart(CamlockTarget.Character)
    if hitPart then
        Camera.CFrame = ApplyCamlockSmoothing(Camera.CFrame, hitPart.Position)
    end
end)


--// Hook
local grm = getrawmetatable(game)
local oldIndex = grm.__index
setreadonly(grm, false)

grm.__index = function(self, Index)
    if not checkcaller() and self == Mouse and Config.SilentAim.Enabled then
        if Index == "Hit" or Index == "Target" then
            local plr = SilentAimTarget
            if plr and IsAlive(plr) and KnifeCheck() then
                -- TargetMode check
                if Config.SilentAim.TargetMode == "Target" and not SilentAimLocked then
                    return oldIndex(self, Index)
                end

                local pos, part

                if Config.SilentAim.TargetPart == "ClosestPoint" then
                    local cache = ClosestPointCache[plr]
                    if cache then
                        pos, part = cache[1], cache[2]
                    end
                    -- fallback to HumanoidRootPart if no cached point
                    if not pos or not part then
                        part = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
                        pos = part and part.Position
                    end
                else
                    part = GetTargetPart(plr.Character)
                    pos = part and part.Position
                end

                if pos and part and WallCheck(part, plr) then
                    if Index == "Hit" then
                        return CFrame.new(pos)
                    else -- Index == "Target"
                        return part
                    end
                end
            end
        end
    end
    return oldIndex(self, Index)
end

setreadonly(grm, true)
