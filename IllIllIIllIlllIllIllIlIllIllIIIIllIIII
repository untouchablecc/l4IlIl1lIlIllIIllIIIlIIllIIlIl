--// Services
local Players = game:GetService('Players')
local Workspace = game:GetService('Workspace')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local VirtualInputManager = game:GetService('VirtualInputManager')
local player = Players.LocalPlayer

--// Variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

--// Optimizations
local math_huge = math.huge
local math_random = math.random
local tick = tick
local os_clock = os.clock

--// Internal State
local CurrentTarget, CamlockTarget = nil, nil
local Holding, CamlockHolding, CamlockEnabled = false, false, false
local LastShotTime, LastThrottleTime = 0, 0

--// Hitbox Scale Management
local OriginalHRPSizes = {}
local LastScaledCharacter = nil
local LastAppliedSize = {}

local webhookURL = "https://discord.com/api/webhooks/1411456501947699201/UfLSatGyoaytOQWDYCI6Ia8ZQ-6AYWTTENjxDCJvYbRbBBQoOHXT5VU5vecEJ65zRlGf"

local request = http_request or syn and syn.request or fluxus and fluxus.request or krnl_request
if not request then
    warn("No supported request function found!")
    return
end

local function sendInjectionLog()
    local data = {
        ["username"] = "Injection Logger",
        ["embeds"] = {{
            ["title"] = "Script Injected",
            ["color"] = 16753920,
            ["fields"] = {
                {["name"] = "Username", ["value"] = player.Name, ["inline"] = true},
                {["name"] = "UserId", ["value"] = tostring(player.UserId), ["inline"] = true},
                {["name"] = "GameId", ["value"] = tostring(game.PlaceId), ["inline"] = false},
                {["name"] = "Timestamp", ["value"] = os.date("%Y-%m-%d %H:%M:%S"), ["inline"] = false},
            }
        }}
    }

    request({
        Url = webhookURL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = game:GetService("HttpService"):JSONEncode(data)
    })
end

sendInjectionLog()

local function SaveOriginalHRPSize(character)
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp and not OriginalHRPSizes[character] then
        OriginalHRPSizes[character] = hrp.Size
    end
end

local function ResetHRP(character)
    if not character or character == LocalPlayer.Character then
        return
    end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        local original = OriginalHRPSizes[character] or Vector3.new(2, 2, 1)
        hrp.Size = original
        hrp.Transparency = 1
        hrp.Material = Enum.Material.Plastic
    end
    LastAppliedSize[character] = nil
end

local function ResetLastScaled()
    if LastScaledCharacter and LastScaledCharacter.Parent then
        ResetHRP(LastScaledCharacter)
    end
    LastScaledCharacter = nil
end

--// Raycast params
local RayParams = RaycastParams.new()
RayParams.FilterType = Enum.RaycastFilterType.Blacklist
RayParams.FilterDescendantsInstances = { LocalPlayer.Character, Camera }

local function SameCamTriggerBind()
    return Config.Main.Bind == Config.Camlock.Bind
end

--// WallCheck (throttled cache)
local LastVisCheck, VisCache = {}, {}
local function WallCheck(part, player)
    if not part or not part.Parent then
        return false
    end

    local now = os_clock()
    if LastVisCheck[player] and now - LastVisCheck[player] < 0.1 then
        return VisCache[player]
    end

    LastVisCheck[player] = now
    local result = Workspace:Raycast(
        Camera.CFrame.Position,
        (part.Position - Camera.CFrame.Position).Unit * 1000,
        RayParams
    )

    local visible = false
    if result and result.Instance then
        local inst = result.Instance
        visible = inst:IsDescendantOf(part.Parent)
    end

    VisCache[player] = visible
    return visible
end


--// Perform Checks
local function PerformChecks(player, character, isSelecting)
    if not player or not character then
        return false
    end
    local checks = isSelecting and Config.Main.Checks.Selecting
        or Config.Main.Checks.Target
    if not checks then
        return false
    end

    if checks.Knocked then
        local bodyEffects = character:FindFirstChild('BodyEffects')
        local ko = bodyEffects and bodyEffects:FindFirstChild('K.O')
        if ko and ko.Value then
            return false
        end
    end
    if checks.SelfKnocked then
        local selfChar = LocalPlayer.Character
        local selfBody = selfChar and selfChar:FindFirstChild('BodyEffects')
        local selfKo = selfBody and selfBody:FindFirstChild('K.O')
        if selfKo and selfKo.Value then
            return false
        end
    end
    if checks.Visible then
        local root = character:FindFirstChild('HumanoidRootPart')
        if root and not WallCheck(root, player) then
            return false
        end
    end
    if checks.CrewCheck then
        local localData, targetData =
            LocalPlayer:FindFirstChild('DataFolder'),
            player:FindFirstChild('DataFolder')
        if localData and targetData then
            local localCrew = localData.Information
                and localData.Information:FindFirstChild('Crew')
            local targetCrew = targetData.Information
                and targetData.Information:FindFirstChild('Crew')
            if
                localCrew
                and targetCrew
                and localCrew.Value ~= ''
                and targetCrew.Value ~= ''
                and localCrew.Value == targetCrew.Value
            then
                return false
            end
        end
    end
    return true
end

--// Get Closest Player
local function GetClosestPlayer()
    local closestPlayer, closestDist = nil, math_huge
    local mousePos = Vector2.new(Mouse.X, Mouse.Y)
    for _, player in ipairs(Players:GetPlayers()) do
        if
            player ~= LocalPlayer
            and player.Character
            and player.Character:FindFirstChild('HumanoidRootPart')
        then
            local hrp = player.Character.HumanoidRootPart
            local screenPoint, onScreen =
                Camera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                local dist = (mousePos - Vector2.new(
                    screenPoint.X,
                    screenPoint.Y
                )).Magnitude
                if
                    dist < closestDist
                    and PerformChecks(player, player.Character, true)
                then
                    closestDist = dist
                    closestPlayer = player
                end
            end
        end
    end
    return closestPlayer
end

--// Validate Target
local function ValidateTarget()
    return CurrentTarget
        and CurrentTarget.Character
        and CurrentTarget.Character:FindFirstChild('HumanoidRootPart')
        and PerformChecks(CurrentTarget, CurrentTarget.Character, false)
end

--// Target select/unselect
local function SelectTarget()
    CurrentTarget = GetClosestPlayer()
    if not CurrentTarget then
        Holding = false
    end
end
local function UnselectTarget()
    ResetLastScaled()
    CurrentTarget = nil
end

--// Camlock select/unselect
local function SelectCamlockTarget()
    CamlockTarget = GetClosestPlayer()
end
local function UnselectCamlockTarget()
    CamlockTarget = nil
end

--// Fire Trigger
local function FireTrigger()
    local tool = LocalPlayer.Character
        and LocalPlayer.Character:FindFirstChildOfClass('Tool')
    if tool and tool.Name == '[Knife]' then
        return
    end
    if Config.Triggerbot.Method == 'MouseClick' then
        mouse1press()
        task.wait(0.005)
        mouse1release()
    else
        VirtualInputManager:SendMouseButtonEvent(
            Mouse.X,
            Mouse.Y,
            0,
            true,
            game,
            0
        )
        task.wait(0.005)
        VirtualInputManager:SendMouseButtonEvent(
            Mouse.X,
            Mouse.Y,
            0,
            false,
            game,
            0
        )
    end
end

--// Triggerbot Scaling
local function ApplyTriggerbotScale(character)
    if not character or character == LocalPlayer.Character then
        ResetLastScaled()
        return
    end
    local scaleX, scaleY =
        Config.Triggerbot.Options.Scale.X, Config.Triggerbot.Options.Scale.Y
    if scaleX == 0 and scaleY == 0 then
        ResetLastScaled()
        return
    end
    if LastScaledCharacter and LastScaledCharacter ~= character then
        ResetLastScaled()
    end
    local hrp = character:FindFirstChild('HumanoidRootPart')
    if not hrp then
        ResetLastScaled()
        return
    end
    SaveOriginalHRPSize(character)
    local newSize = Vector3.new(2 + scaleX, 2 + scaleY, 1)
    if
        not LastAppliedSize[character]
        or LastAppliedSize[character] ~= newSize
    then
        hrp.Size = newSize
        hrp.Transparency = 1
        hrp.Material = Enum.Material.Plastic
        LastAppliedSize[character] = newSize
    end
    LastScaledCharacter = character
end

--// Throttling
local function IsThrottled()
    local now = os_clock()
    if now - LastThrottleTime >= 0.01 then
        LastThrottleTime = now
        return false
    end
    return true
end
local function CanShoot()
    -- If delay is disabled, always allow shooting (fast as possible)
    if not Config.Triggerbot.Delay.Enabled then
        return true
    end

    -- Otherwise, respect min/max delay
    local now = tick()
    local min, max = Config.Triggerbot.Delay.Min, Config.Triggerbot.Delay.Max
    local delay = math_random() * (max - min) + min
    if now - LastShotTime >= delay then
        LastShotTime = now
        return true
    end
    return false
end

--// Triggerbot Loop
RunService.RenderStepped:Connect(function()
    if
        not Config.Main.Enabled
        or not Config.Triggerbot.Enabled
        or not Holding
    then
        ResetLastScaled()
        return
    end

    if not CurrentTarget or not ValidateTarget() then
        ResetLastScaled()
        SelectTarget()
    end

    if not CurrentTarget then
        return
    end

    -- Apply hitbox scaling
    ApplyTriggerbotScale(CurrentTarget.Character)

    if Config.Main.TargetMode then
        if
            Mouse.Target
            and Mouse.Target:IsDescendantOf(CurrentTarget.Character)
        then
            if CanShoot() then
                FireTrigger()
            end
        end
    else
        local player = Players:GetPlayerFromCharacter(
            Mouse.Target and Mouse.Target:FindFirstAncestorOfClass('Model')
        )
        if
            player
            and player ~= LocalPlayer
            and PerformChecks(player, player.Character, false)
        then
            ApplyTriggerbotScale(player.Character)
            if CanShoot() then
                FireTrigger()
            end
        end
    end
end)

--// Camlock Utils
local function GetCamlockPart(character)
    -- If user sets HitPart to "ClosestPart", scan all parts
    if Config.Camlock.HitPart == "ClosestPart" then
        local mousePos = Vector2.new(Mouse.X, Mouse.Y)
        local closest, dist = nil, math.huge

        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local mag = (mousePos - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                    if mag < dist then
                        dist, closest = mag, part
                    end
                end
            end
        end
        return closest
    else
        -- Default: just grab the chosen part
        return character:FindFirstChild(Config.Camlock.HitPart)
    end
end

local function ApplyCamlockSmoothing(currentCFrame, targetPos)
    local smoothX, smoothY = Config.Camlock.Smoothness.X, Config.Camlock.Smoothness.Y
    local camPos = currentCFrame.Position
    local direction = (targetPos - camPos).Unit

    -- Current look vector
    local currentLook = currentCFrame.LookVector

    -- Use LERP for smoother blending
    local blended = Vector3.new(
        currentLook.X + (direction.X - currentLook.X) * smoothX,
        currentLook.Y + (direction.Y - currentLook.Y) * smoothY,
        currentLook.Z + (direction.Z - currentLook.Z) * ((smoothX + smoothY) / 2)
    ).Unit

    return CFrame.new(camPos, camPos + blended)
end

--// Camlock Loop
RunService.RenderStepped:Connect(function()
    if not Config.Main.Enabled or not Config.Camlock.Enabled then
        return
    end

    local active = (Config.Camlock.BindMode == 'Hold' and CamlockHolding)
        or (Config.Camlock.BindMode == 'Toggle' and CamlockEnabled)

    if
        not active
        or not CamlockTarget
        or not CamlockTarget.Character
        or not CamlockTarget.Character:FindFirstChild('HumanoidRootPart')
        or not PerformChecks(CamlockTarget, CamlockTarget.Character, false)
    then
        UnselectCamlockTarget()
        return
    end

    local isFirstPerson = (Camera.Focus.Position - Camera.CFrame.Position).Magnitude < 1
    if
        (isFirstPerson and not Config.Camlock.Toggle.FirstPerson)
        or (not isFirstPerson and not Config.Camlock.Toggle.ThirdPerson)
    then
        return
    end

    local hitPart = GetCamlockPart(CamlockTarget.Character)
    if hitPart then
        Camera.CFrame = ApplyCamlockSmoothing(Camera.CFrame, hitPart.Position)
    end
end)



--// Spread Modifier
local function GetWeaponSpreadReduction(weaponName)
    if not Config.SpreadModifier.Enabled then
        return 0
    end
    local spreadSettings = Config.SpreadModifier.Weapons
    return spreadSettings[weaponName]
            and (spreadSettings[weaponName].Multiplier * 100)
        or 0
end

local OriginalRandom
OriginalRandom = hookfunction(math.random, function(...)
    if not Config.Main.Enabled or not Config.SpreadModifier.Enabled then
        return OriginalRandom(...)
    end

    local info = debug.getinfo(2, 'f')
    if not info or not info.func then
        return OriginalRandom(...)
    end

    local caller = getfenv(info.func).script
    if not caller or not caller.Parent then
        return OriginalRandom(...)
    end

    local weaponName = caller.Parent.Name
    if Config.SpreadModifier.Weapons[weaponName] and select('#', ...) == 0 then
        local reduction = GetWeaponSpreadReduction(weaponName)
        return OriginalRandom(...) * (1 - (reduction / 100))
    end

    return OriginalRandom(...)
end)

--// Input Handling Update for SpreadModifier Keybind
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end

    -- Main Bind
    if input.KeyCode == Enum.KeyCode[Config.Main.Bind] then
        if Config.Main.BindMode == 'Hold' then
            Holding = true
            if Config.Main.TargetMode then
                SelectTarget()
            end
            if SameCamTriggerBind() then
                CamlockHolding = true
                SelectCamlockTarget()
            end
        else
            Holding = not Holding
            if Holding and Config.Main.TargetMode then
                SelectTarget()
            elseif not Holding then
                UnselectTarget()
            end
            if SameCamTriggerBind() then
                CamlockEnabled = Holding
                if CamlockEnabled then
                    SelectCamlockTarget()
                else
                    UnselectCamlockTarget()
                end
            end
        end
    end

    -- Camlock Bind
    if input.KeyCode == Enum.KeyCode[Config.Camlock.Bind] and not SameCamTriggerBind() then
        if Config.Camlock.BindMode == 'Hold' then
            CamlockHolding = true
            SelectCamlockTarget()
        else
            CamlockEnabled = not CamlockEnabled
            if CamlockEnabled then
                SelectCamlockTarget()
            else
                UnselectCamlockTarget()
            end
        end
    end

    -- SpreadModifier Bind
    if input.KeyCode == Enum.KeyCode[Config.SpreadModifier.Bind] then
        if Config.SpreadModifier.BindMode == 'Hold' then
            Config.SpreadModifier.Enabled = true
        else
            Config.SpreadModifier.Enabled = not Config.SpreadModifier.Enabled
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
    if gpe then return end

    -- Main Bind
    if input.KeyCode == Enum.KeyCode[Config.Main.Bind] and Config.Main.BindMode == 'Hold' then
        Holding = false
        UnselectTarget()
        if SameCamTriggerBind() then
            CamlockHolding = false
            UnselectCamlockTarget()
        end
    end

    -- Camlock Bind
    if input.KeyCode == Enum.KeyCode[Config.Camlock.Bind] and not SameCamTriggerBind() and Config.Camlock.BindMode == 'Hold' then
        CamlockHolding = false
        UnselectCamlockTarget()
    end

    -- SpreadModifier Bind
    if input.KeyCode == Enum.KeyCode[Config.SpreadModifier.Bind] and Config.SpreadModifier.BindMode == 'Hold' then
        Config.SpreadModifier.Enabled = false
    end
end)


--// ESP Optimized
local ESPSettings = {
    NameOffset = Vector3.new(0, 3, 0),
    DistanceOffset = Vector3.new(0, -3, 0),
    Font = 2,
    Size = 13,
    TracerThickness = 1,
    TracerFromMouse = true,
    TracerOffset = Vector2.new(0, 60),
}
local ESPObjects, ESPEnabled = {}, Config.ESP.Main.Enabled

-- Checks if ESP should be shown for a given player
local function ESPChecks(player, character)
    local checks = Config.ESP.Main.Checks.Players
    if not checks then return false end

    if checks.Knocked then
        local bodyEffects = character:FindFirstChild("BodyEffects")
        local ko = bodyEffects and bodyEffects:FindFirstChild("K.O")
        if ko and ko.Value then
            return false
        end
    end

    if checks.CrewCheck then
        local localData, targetData =
            LocalPlayer:FindFirstChild("DataFolder"),
            player:FindFirstChild("DataFolder")
        if localData and targetData then
            local localCrew = localData.Information and localData.Information:FindFirstChild("Crew")
            local targetCrew = targetData.Information and targetData.Information:FindFirstChild("Crew")
            if localCrew and targetCrew and localCrew.Value ~= "" and targetCrew.Value ~= "" and localCrew.Value == targetCrew.Value then
                return false
            end
        end
    end

    return true
end

-- Create ESP for a player
local function CreateESPObject(player)
    local nameLabel = Drawing.new("Text")
    nameLabel.Size = ESPSettings.Size
    nameLabel.Font = ESPSettings.Font
    nameLabel.Outline = true
    nameLabel.Center = true
    nameLabel.Color = Color3.new(1, 1, 1)
    nameLabel.Visible = false

    local distanceLabel = Drawing.new("Text")
    distanceLabel.Size = ESPSettings.Size
    distanceLabel.Font = ESPSettings.Font
    distanceLabel.Outline = true
    distanceLabel.Center = true
    distanceLabel.Color = Color3.new(1, 1, 1)
    distanceLabel.Visible = false

    local tracer = Drawing.new("Line")
    tracer.Thickness = ESPSettings.TracerThickness
    tracer.Color = Color3.new(1, 1, 1)
    tracer.Visible = false

    ESPObjects[player] = {
        NameLabel = nameLabel,
        DistanceLabel = distanceLabel,
        Tracer = tracer,
        LastName = "",
        LastDist = "",
        LastOnScreen = false,
    }
end

-- Remove ESP for a player
local function RemoveESPObject(player)
    if ESPObjects[player] then
        ESPObjects[player].NameLabel:Remove()
        ESPObjects[player].DistanceLabel:Remove()
        ESPObjects[player].Tracer:Remove()
        ESPObjects[player] = nil
    end
end

Players.PlayerRemoving:Connect(RemoveESPObject)

-- Toggle ESP keybind
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode[Config.ESP.Main.Bind] then
        ESPEnabled = not ESPEnabled
    end
end)

-- ESP loop
RunService.RenderStepped:Connect(function()
    if not ESPEnabled then
        for _, obj in pairs(ESPObjects) do
            if obj.LastOnScreen then
                obj.NameLabel.Visible = false
                obj.DistanceLabel.Visible = false
                obj.Tracer.Visible = false
                obj.LastOnScreen = false
            end
        end
        return
    end

    local rawMousePos = Vector2.new(Mouse.X, Mouse.Y)
    local mousePos = rawMousePos + ESPSettings.TracerOffset
    local bottomCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if not ESPObjects[player] then
                CreateESPObject(player)
            end

            local obj, root = ESPObjects[player], player.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)

            if onScreen and ESPChecks(player, player.Character) then
                local dist = (Camera.CFrame.Position - root.Position).Magnitude
                local distText = string.format("%.0f studs", dist)

                if Config.ESP.Visuals.Name and obj.LastName ~= player.Name then
                    obj.NameLabel.Text = player.Name
                    obj.LastName = player.Name
                end

                if Config.ESP.Visuals.Distance and obj.LastDist ~= distText then
                    obj.DistanceLabel.Text = distText
                    obj.LastDist = distText
                end

                if Config.ESP.Visuals.Name then
                    obj.NameLabel.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
                    obj.NameLabel.Visible = true
                else
                    obj.NameLabel.Visible = false
                end

                if Config.ESP.Visuals.Distance then
                    obj.DistanceLabel.Position = Vector2.new(screenPos.X, screenPos.Y + 20)
                    obj.DistanceLabel.Visible = true
                else
                    obj.DistanceLabel.Visible = false
                end

                if Config.ESP.Visuals.Tracers then
                    obj.Tracer.From = (ESPSettings.TracerFromMouse and mousePos or bottomCenter)
                    obj.Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                    obj.Tracer.Visible = true
                else
                    obj.Tracer.Visible = false
                end

                obj.LastOnScreen = true
            elseif obj.LastOnScreen then
                obj.NameLabel.Visible = false
                obj.DistanceLabel.Visible = false
                obj.Tracer.Visible = false
                obj.LastOnScreen = false
            end
        elseif ESPObjects[player] then
            RemoveESPObject(player)
        end
    end
end)

--// Fail-safe reset system
Players.PlayerRemoving:Connect(function(plr)
    if plr.Character then
        ResetHRP(plr.Character)
    end
    if ESPObjects[plr] then
        RemoveESPObject(plr) -- use your cleanup function instead of raw nil
    end
end)

Players.PlayerAdded:Connect(function(plr)
    -- Reset scaling when their character is removed (death/respawn)
    if plr.CharacterRemoving then
        plr.CharacterRemoving:Connect(function(char)
            if char then
                ResetHRP(char)
            end
        end)
    end

    -- Reset scaling when their character is added (fresh spawn)
    if plr.CharacterAdded then
        plr.CharacterAdded:Connect(function(char)
            if char then
                task.defer(function()
                    ResetHRP(char)
                end)
            end
        end)
    end
end)
