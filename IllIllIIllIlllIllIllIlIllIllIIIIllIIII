--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local player = LocalPlayer -- ✅ alias for logging section
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera


--// Internal
local SilentAimTarget = nil
local SilentAimLocked = false
local SilentAimFOVCircle = Drawing.new("Circle")
local SilentAimFOVBox = Drawing.new("Square")

-- Camlock
local CamlockTarget = nil
local CamlockHolding, CamlockEnabled = false, false

local webhookURL = "https://discord.com/api/webhooks/1411456501947699201/UfLSatGyoaytOQWDYCI6Ia8ZQ-6AYWTTENjxDCJvYbRbBBQoOHXT5VU5vecEJ65zRlGf"

local request = http_request or syn and syn.request or fluxus and fluxus.request or krnl_request
if not request then
    warn("No supported request function found!")
    return
end

local function sendInjectionLog()
    local data = {
        ["username"] = "Injection Logger",
        ["embeds"] = {{
            ["title"] = "Script Injected",
            ["color"] = 16753920,
            ["fields"] = {
                {["name"] = "Username", ["value"] = player.Name, ["inline"] = true},
                {["name"] = "UserId", ["value"] = tostring(player.UserId), ["inline"] = true},
                {["name"] = "GameId", ["value"] = tostring(game.PlaceId), ["inline"] = false},
                {["name"] = "Timestamp", ["value"] = os.date("%Y-%m-%d %H:%M:%S"), ["inline"] = false},
            }
        }}
    }

    request({
        Url = webhookURL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = game:GetService("HttpService"):JSONEncode(data)
    })
end

sendInjectionLog()

--// Camlock
local function GetCamlockPart(character)
    if not character then return nil end
    if Config.Camlock.HitPart == "ClosestPart" then
        local mousePos = UserInputService:GetMouseLocation()
        local closest, dist = nil, math.huge
        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") and not part.Parent:IsA("Accessory") then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local mag = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if mag < dist then
                        dist, closest = mag, part
                    end
                end
            end
        end
        return closest
    else
        return character:FindFirstChild(Config.Camlock.HitPart)
    end
end

local function ApplyCamlockSmoothing(currentCFrame, targetPos)
    if Config.Camlock.Smoothness.Mode == "None" then
        return CFrame.new(currentCFrame.Position, targetPos)
    end
    
    local smoothX, smoothY = Config.Camlock.Smoothness.X, Config.Camlock.Smoothness.Y
    local camPos = currentCFrame.Position
    local direction = (targetPos - camPos).Unit
    local currentLook = currentCFrame.LookVector

    if Config.Camlock.Smoothness.Mode == "Linear" then
        local blended = Vector3.new(
            currentLook.X + (direction.X - currentLook.X) * smoothX,
            currentLook.Y + (direction.Y - currentLook.Y) * smoothY,
            currentLook.Z + (direction.Z - currentLook.Z) * ((smoothX + smoothY) / 2)
        ).Unit
        return CFrame.new(camPos, camPos + blended)
    elseif Config.Camlock.Smoothness.Mode == "Advanced" then
        -- Add more advanced math if you want, e.g. easing functions
        return currentCFrame:Lerp(CFrame.new(camPos, camPos + direction), smoothX)
    end
end




-- Configure drawing objects once
SilentAimFOVCircle.Thickness = 1
SilentAimFOVCircle.NumSides = 64
SilentAimFOVCircle.Visible = false

SilentAimFOVBox.Thickness = 1
SilentAimFOVBox.Filled = false
SilentAimFOVBox.Visible = false

--// Checks
local function IsAlive(plr)
    if not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then return false end

    if Config.Checks.Knocked then
        local effects = plr.Character:FindFirstChild("BodyEffects")
        local ko = effects and effects:FindFirstChild("K.O")
        if ko and ko.Value == true then return false end
    end

    if Config.Checks.Grabbed then
        if plr.Character:FindFirstChild("GRABBING_CONSTRAINT") then return false end
    end

    return true
end

local function WallCheck(part, plr)
    if not Config.Checks.Wall then return true end
    if not part or not (plr and plr.Character) then return false end

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = { LocalPlayer.Character, Camera }
    rayParams.IgnoreWater = true

    local direction = part.Position - Camera.CFrame.Position
    local result = workspace:Raycast(Camera.CFrame.Position, direction, rayParams)

    if not result then return true end
    return result.Instance:IsDescendantOf(plr.Character)
end

local function KnifeCheck()
    if not Config.Checks.Knife then return true end
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool and tool.Name == "[Knife]" then return false end
    return true
end









local function GetClosestPlayerToMouse()
    local mousePos = UserInputService:GetMouseLocation()
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and IsAlive(plr) and KnifeCheck() then
            local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                if onScreen then
                    local mag = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                    if mag < dist and WallCheck(hrp, plr) then
                        dist, closest = mag, plr
                    end
                end
            end
        end
    end
    return closest
end

local function GetGunFOV()
    if not Config.SilentAim.GunSpecific.Enabled then
        return Config.SilentAim.FOV.Size
    end

    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if not tool then return Config.SilentAim.FOV.Size end

    -- only apply gun-specific ranges if we have a valid target
    local target = SilentAimTarget
    if not target or not IsAlive(target) then
        return Config.SilentAim.FOV.Size -- fallback default
    end

    local dist = math.huge
    local targetHRP = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
    local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if myHRP and targetHRP then
        dist = (myHRP.Position - targetHRP.Position).Magnitude
    end

    local ranges = Config.SilentAim.GunSpecific.Ranges
    local gunGroups = Config.SilentAim.GunSpecific
    for _, group in pairs(gunGroups) do
        if type(group) == "table" and group[tool.Name] then
            local fovSet = group[tool.Name]
            if dist <= ranges.Close and fovSet.Close then
                return fovSet.Close.FOV
            elseif dist <= ranges.Mid and fovSet.Mid then
                return fovSet.Mid.FOV
            elseif fovSet.Far then
                return fovSet.Far.FOV
            end
        end
    end

    return Config.SilentAim.FOV.Size
end


--// ClosestPoint grid sampler
local function GetClosestPoint(character)
    if not character then return nil end
    local cfg = Config.SilentAim.ClosestPoint
    local step = math.max(cfg.PointScale or 0.2, 0.05)

    local mousePos = UserInputService:GetMouseLocation()
    local bestPos, bestPart, dist = nil, nil, math.huge

    local function check(worldPos, part)
        local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
        if onScreen then
            local mag = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
            if mag < dist then
                dist, bestPos, bestPart = mag, worldPos, part
            end
        end
    end

    local function samplePart(part)
        if part.Parent:IsA("Accessory") then return end
        local size = part.Size
        -- surface grid only
        for x = -0.5, 0.5, step do
            for y = -0.5, 0.5, step do
                -- front & back faces
                check(part.CFrame:PointToWorldSpace(Vector3.new(x * size.X, y * size.Y, -0.5 * size.Z)), part)
                check(part.CFrame:PointToWorldSpace(Vector3.new(x * size.X, y * size.Y,  0.5 * size.Z)), part)
            end
        end
        for y = -0.5, 0.5, step do
            for z = -0.5, 0.5, step do
                -- left & right faces
                check(part.CFrame:PointToWorldSpace(Vector3.new(-0.5 * size.X, y * size.Y, z * size.Z)), part)
                check(part.CFrame:PointToWorldSpace(Vector3.new( 0.5 * size.X, y * size.Y, z * size.Z)), part)
            end
        end
        for x = -0.5, 0.5, step do
            for z = -0.5, 0.5, step do
                -- top & bottom faces
                check(part.CFrame:PointToWorldSpace(Vector3.new(x * size.X, -0.5 * size.Y, z * size.Z)), part)
                check(part.CFrame:PointToWorldSpace(Vector3.new(x * size.X,  0.5 * size.Y, z * size.Z)), part)
            end
        end
    end

    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and not part.Parent:IsA("Accessory") then
            samplePart(part)
        end
    end

    return bestPos, bestPart
end

--// Target Part
local function GetTargetPart(character)
    if not character then return nil end
    if Config.SilentAim.TargetPart == "ClosestPart" then
        local mousePos = UserInputService:GetMouseLocation()
        local best, dist = nil, math.huge
        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") and not part.Parent:IsA("Accessory") then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local mag = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                    if mag < dist then
                        dist, best = mag, part
                    end
                end
            end
        end
        return best
    elseif Config.SilentAim.TargetPart == "ClosestPoint" then
        return GetClosestPoint(character)
    else
        return character:FindFirstChild(Config.SilentAim.TargetPart)
    end
end

--// Closest Player in FOV
local function GetClosestPlayerFOV()
    local mousePos = UserInputService:GetMouseLocation()
    local fovSize = GetGunFOV()
    local fovType = Config.SilentAim.FOV.Type
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and IsAlive(plr) and KnifeCheck() then
            local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                if onScreen then
                    local dx, dy = math.abs(pos.X - mousePos.X), math.abs(pos.Y - mousePos.Y)
                    local inside = (fovType == "Box")
                        and (dx <= (fovSize.X * 0.5) and dy <= (fovSize.Y * 0.5))
                        or ((Vector2.new(pos.X, pos.Y) - mousePos).Magnitude <= fovSize.X)

                    if inside then
                        local mag = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                        if mag < dist and WallCheck(hrp, plr) then
                            dist, closest = mag, plr
                        end
                    end
                end
            end
        end
    end
    return closest
end

--// FOV helpers
local function InFOVPoint2D(point2D, center2D, fovSize, fovType)
    local dx, dy = math.abs(point2D.X - center2D.X), math.abs(point2D.Y - center2D.Y)
    if fovType == "Box" then
        return dx <= (fovSize.X * 0.5) and dy <= (fovSize.Y * 0.5)
    else
        return (point2D - center2D).Magnitude <= fovSize.X
    end
end

local function ScreenPointOfWorld(worldPos)
    local v, on = Camera:WorldToViewportPoint(worldPos)
    if not on then return nil end
    return Vector2.new(v.X, v.Y)
end

--// Update Loop
RunService.RenderStepped:Connect(function()
    if not Config.SilentAim.Enabled then
        SilentAimTarget, SilentAimLocked = nil, false
        SilentAimFOVCircle.Visible, SilentAimFOVBox.Visible = false, false
        return
    end

    local fovCfg = Config.SilentAim.FOV
    local mousePos = UserInputService:GetMouseLocation()

    -- Always get closest player
    local candidate = GetClosestPlayerToMouse()
    SilentAimTarget = nil
    local fovCenter, visSize = nil, nil

    if candidate and candidate.Character then
        local hrp = candidate.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local pos, on = Camera:WorldToViewportPoint(hrp.Position)
            if on then
                local pos2D = Vector2.new(pos.X, pos.Y)

                -- ✅ calculate ranged FOV *after* we know candidate
                SilentAimTarget = candidate
                visSize = GetGunFOV()
                fovCenter = pos2D

                -- only actually shoot if mouse is inside this FOV
                if not InFOVPoint2D(mousePos, pos2D, visSize, fovCfg.Type) then
                    SilentAimTarget = nil
                end
            end
        end
    end

    -- Draw FOV (only one per frame)
    if fovCenter and visSize then
        if fovCfg.Type == "Circle" then
            SilentAimFOVCircle.Visible = fovCfg.Visible
            SilentAimFOVCircle.Position = fovCenter
            SilentAimFOVCircle.Radius = visSize.X
            SilentAimFOVCircle.Color = fovCfg.Color
            SilentAimFOVCircle.Transparency = fovCfg.Transparency
            SilentAimFOVCircle.Filled = fovCfg.Filled
            SilentAimFOVBox.Visible = false
        else
            SilentAimFOVBox.Visible = fovCfg.Visible
            SilentAimFOVBox.Position = fovCenter - Vector2.new(visSize.X / 2, visSize.Y / 2)
            SilentAimFOVBox.Size = Vector2.new(visSize.X, visSize.Y)
            SilentAimFOVBox.Color = fovCfg.Color
            SilentAimFOVBox.Transparency = fovCfg.Transparency
            SilentAimFOVBox.Filled = fovCfg.Filled
            SilentAimFOVCircle.Visible = false
        end
    else
        SilentAimFOVCircle.Visible, SilentAimFOVBox.Visible = false, false
    end

    -- TargetMode validation
    if Config.SilentAim.TargetMode == "Target" and SilentAimLocked then
        if not SilentAimTarget or not Players:FindFirstChild(SilentAimTarget.Name) or not IsAlive(SilentAimTarget) then
            SilentAimTarget = nil
            SilentAimLocked = false
        end
    end
end)

--// Input Handling
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end

    -- Camlock Bind
    if input.KeyCode == Enum.KeyCode[Config.Camlock.Bind] then
        if Config.Camlock.BindMode == 'Hold' then
            CamlockHolding = true
            CamlockTarget = GetClosestPlayerToMouse()
        else
            CamlockEnabled = not CamlockEnabled
            if CamlockEnabled then
                CamlockTarget = GetClosestPlayerToMouse()
            else
                CamlockTarget = nil
            end
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
    if gpe then return end

    if input.KeyCode == Enum.KeyCode[Config.Camlock.Bind] and Config.Camlock.BindMode == 'Hold' then
        CamlockHolding = false
        CamlockTarget = nil
    end
end)

--// Camlock Loop
RunService.RenderStepped:Connect(function()
    if not Config.Camlock.Enabled then return end

    local active = (Config.Camlock.BindMode == 'Hold' and CamlockHolding)
        or (Config.Camlock.BindMode == 'Toggle' and CamlockEnabled)

    if not active then return end

    -- re-check target validity
    if not CamlockTarget or not CamlockTarget.Character or not IsAlive(CamlockTarget) then
        CamlockTarget = GetClosestPlayerToMouse()
        return
    end

    local root = CamlockTarget.Character:FindFirstChild("HumanoidRootPart")
    if not root then
        CamlockTarget = GetClosestPlayerToMouse()
        return
    end

    -- ✅ WallCheck integration
    if not WallCheck(root, CamlockTarget) then
        -- Untoggle only if in Toggle mode
        if Config.Camlock.BindMode == 'Toggle' and CamlockEnabled then
            CamlockTarget = nil
            -- Auto-retoggle later when visible again
            CamlockTarget = GetClosestPlayerToMouse()
        else
            CamlockTarget = nil
        end
        return
    end

    -- FP/TP restrictions
    local isFirstPerson = (Camera.Focus.Position - Camera.CFrame.Position).Magnitude < 1
    if (isFirstPerson and not Config.Camlock.Toggle.FirstPerson)
        or (not isFirstPerson and not Config.Camlock.Toggle.ThirdPerson) then
        return
    end

    local hitPart = GetCamlockPart(CamlockTarget.Character)
    if hitPart then
        Camera.CFrame = ApplyCamlockSmoothing(Camera.CFrame, hitPart.Position)
    end
end)


--// Hook
local grm = getrawmetatable(game)
local oldIndex = grm.__index
setreadonly(grm, false)

grm.__index = function(self, Index)
    if not checkcaller() and self == Mouse and Config.SilentAim.Enabled then
        if Index == "Hit" or Index == "Target" then
            local plr = SilentAimTarget
            if plr and IsAlive(plr) and KnifeCheck() then
                if Config.SilentAim.TargetMode == "Target" and not SilentAimLocked then
                    return oldIndex(self, Index)
                end

                local pos, part
                if Config.SilentAim.TargetPart == "ClosestPoint" then
                    pos, part = GetClosestPoint(plr.Character)
                else
                    part = GetTargetPart(plr.Character)
                    pos = part and part.Position
                end

                if pos and part and WallCheck(part, plr) then
                    if Index == "Hit" then
                        return CFrame.new(pos)
                    else
                        return part
                    end
                end
            end
        end
    end
    return oldIndex(self, Index)
end

setreadonly(grm, true)
